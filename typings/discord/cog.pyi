import types
from .commands import ApplicationCommand, ApplicationContext
from _typeshed import Incomplete
from typing import Any, Callable, ClassVar, Generator, Mapping, TypeVar, overload

__all__ = ['CogMeta', 'Cog', 'CogMixin']

CogT = TypeVar('CogT', bound='Cog')
FuncT = TypeVar('FuncT', bound=Callable[..., Any])

class CogMeta(type):
    __cog_name__: str
    __cog_settings__: dict[str, Any]
    __cog_commands__: list[ApplicationCommand]
    __cog_listeners__: list[tuple[str, str]]
    __cog_guild_ids__: list[int]
    def __new__(cls, *args: Any, **kwargs: Any) -> CogMeta: ...
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    @classmethod
    def qualified_name(cls) -> str: ...

class Cog(metaclass=CogMeta):
    __cog_name__: ClassVar[str]
    __cog_settings__: ClassVar[dict[str, Any]]
    __cog_commands__: ClassVar[list[ApplicationCommand]]
    __cog_listeners__: ClassVar[list[tuple[str, str]]]
    __cog_guild_ids__: ClassVar[list[int]]
    def __new__(cls, *args: Any, **kwargs: Any) -> CogT: ...
    def get_commands(self) -> list[ApplicationCommand]: ...
    @property
    def qualified_name(self) -> str: ...
    @property
    def description(self) -> str: ...
    __cog_description__: Incomplete
    @description.setter
    def description(self, description: str) -> None: ...
    def walk_commands(self) -> Generator[ApplicationCommand, None, None]: ...
    def get_listeners(self) -> list[tuple[str, Callable[..., Any]]]: ...
    @classmethod
    def listener(cls, name: str = ..., once: bool = False) -> Callable[[FuncT], FuncT]: ...
    def has_error_handler(self) -> bool: ...
    @_cog_special_method
    def cog_unload(self) -> None: ...
    @_cog_special_method
    def bot_check_once(self, ctx: ApplicationContext) -> bool: ...
    @_cog_special_method
    def bot_check(self, ctx: ApplicationContext) -> bool: ...
    @_cog_special_method
    def cog_check(self, ctx: ApplicationContext) -> bool: ...
    @_cog_special_method
    async def cog_command_error(self, ctx: ApplicationContext, error: Exception) -> None: ...
    @_cog_special_method
    async def cog_before_invoke(self, ctx: ApplicationContext) -> None: ...
    @_cog_special_method
    async def cog_after_invoke(self, ctx: ApplicationContext) -> None: ...

class CogMixin:
    def __init__(self, *args, **kwargs) -> None: ...
    def add_cog(self, cog: Cog, *, override: bool = False) -> None: ...
    def get_cog(self, name: str) -> Cog | None: ...
    def remove_cog(self, name: str) -> Cog | None: ...
    @property
    def cogs(self) -> Mapping[str, Cog]: ...
    @overload
    def load_extension(self, name: str, *, package: str | None = None, recursive: bool = False) -> list[str]: ...
    @overload
    def load_extension(self, name: str, *, package: str | None = None, recursive: bool = False, store: bool = False) -> dict[str, Exception | bool] | list[str] | None: ...
    @overload
    def load_extensions(self, *names: str, package: str | None = None, recursive: bool = False) -> list[str]: ...
    @overload
    def load_extensions(self, *names: str, package: str | None = None, recursive: bool = False, store: bool = False) -> dict[str, Exception | bool] | list[str] | None: ...
    def unload_extension(self, name: str, *, package: str | None = None) -> None: ...
    def reload_extension(self, name: str, *, package: str | None = None) -> None: ...
    @property
    def extensions(self) -> Mapping[str, types.ModuleType]: ...
