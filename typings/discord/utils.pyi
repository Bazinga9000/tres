import array
import collections.abc
import datetime
from .abc import Snowflake
from .commands.context import AutocompleteContext
from .commands.options import OptionChoice
from .invite import Invite
from .permissions import Permissions
from .template import Template
from _typeshed import Incomplete
from typing import Any, AsyncIterator, Awaitable, Callable, Generic, Iterable, Iterator, Mapping, Protocol, Sequence, TypeVar, overload
from typing_extensions import ParamSpec

__all__ = ['parse_time', 'warn_deprecated', 'deprecated', 'oauth_url', 'snowflake_time', 'time_snowflake', 'find', 'get', 'get_or_fetch', 'sleep_until', 'utcnow', 'resolve_invite', 'resolve_template', 'remove_markdown', 'escape_markdown', 'escape_mentions', 'raw_mentions', 'raw_channel_mentions', 'raw_role_mentions', 'as_chunks', 'format_dt', 'generate_snowflake', 'basic_autocomplete', 'filter_params']

class _MissingSentinel:
    def __eq__(self, other) -> bool: ...
    def __bool__(self) -> bool: ...

class _cached_property:
    function: Incomplete
    __doc__: Incomplete
    def __init__(self, function) -> None: ...
    def __get__(self, instance, owner): ...

class _RequestLike(Protocol):
    headers: Mapping[str, Any]
P = ParamSpec('P')
T = TypeVar('T')
T_co = TypeVar('T_co', covariant=True)

class CachedSlotProperty(Generic[T, T_co]):
    name: Incomplete
    function: Incomplete
    __doc__: Incomplete
    def __init__(self, name: str, function: Callable[[T], T_co]) -> None: ...
    @overload
    def __get__(self, instance: None, owner: type[T]) -> CachedSlotProperty[T, T_co]: ...
    @overload
    def __get__(self, instance: T, owner: type[T]) -> T_co: ...

class classproperty(Generic[T_co]):
    fget: Incomplete
    def __init__(self, fget: Callable[[Any], T_co]) -> None: ...
    def __get__(self, instance: Any | None, owner: type[Any]) -> T_co: ...
    def __set__(self, instance, value) -> None: ...

class SequenceProxy(collections.abc.Sequence, Generic[T_co]):
    def __init__(self, proxied: Sequence[T_co]) -> None: ...
    def __getitem__(self, idx: int) -> T_co: ...
    def __len__(self) -> int: ...
    def __contains__(self, item: Any) -> bool: ...
    def __iter__(self) -> Iterator[T_co]: ...
    def __reversed__(self) -> Iterator[T_co]: ...
    def index(self, value: Any, *args, **kwargs) -> int: ...
    def count(self, value: Any) -> int: ...

@overload
def parse_time(timestamp: None) -> None: ...
@overload
def parse_time(timestamp: str) -> datetime.datetime: ...
@overload
def parse_time(timestamp: str | None) -> datetime.datetime | None: ...
def warn_deprecated(name: str, instead: str | None = None, since: str | None = None, removed: str | None = None, reference: str | None = None, stacklevel: int = 3) -> None: ...
def deprecated(instead: str | None = None, since: str | None = None, removed: str | None = None, reference: str | None = None, stacklevel: int = 3, *, use_qualname: bool = True) -> Callable[[Callable[[P], T]], Callable[[P], T]]: ...
def oauth_url(client_id: int | str, *, permissions: Permissions = ..., guild: Snowflake = ..., redirect_uri: str = ..., scopes: Iterable[str] = ..., disable_guild_select: bool = False) -> str: ...
def snowflake_time(id: int) -> datetime.datetime: ...
def time_snowflake(dt: datetime.datetime, high: bool = False) -> int: ...
def find(predicate: Callable[[T], Any], seq: Iterable[T]) -> T | None: ...
def get(iterable: Iterable[T], **attrs: Any) -> T | None: ...
async def get_or_fetch(obj, attr: str, id: int, *, default: Any = ...) -> Any: ...
async def sleep_until(when: datetime.datetime, result: T | None = None) -> T | None: ...
def utcnow() -> datetime.datetime: ...

class SnowflakeList(array.array):
    def __init__(self, data: Iterable[int], *, is_sorted: bool = False) -> None: ...
    def __new__(cls, data: Iterable[int], *, is_sorted: bool = False): ...
    def add(self, element: int) -> None: ...
    def get(self, element: int) -> int | None: ...
    def has(self, element: int) -> bool: ...

def resolve_invite(invite: Invite | str) -> str: ...
def resolve_template(code: Template | str) -> str: ...
def remove_markdown(text: str, *, ignore_links: bool = True) -> str: ...
def escape_markdown(text: str, *, as_needed: bool = False, ignore_links: bool = True) -> str: ...
def escape_mentions(text: str) -> str: ...
def raw_mentions(text: str) -> list[int]: ...
def raw_channel_mentions(text: str) -> list[int]: ...
def raw_role_mentions(text: str) -> list[int]: ...
@overload
def as_chunks(iterator: Iterator[T], max_size: int) -> Iterator[list[T]]: ...
@overload
def as_chunks(iterator: AsyncIterator[T], max_size: int) -> AsyncIterator[list[T]]: ...
def format_dt(dt: datetime.datetime, /, style: TimestampStyle | None = None) -> str: ...
def generate_snowflake(dt: datetime.datetime | None = None) -> int: ...
V = Iterable[OptionChoice] | Iterable[str] | Iterable[int] | Iterable[float]
AV = Awaitable[V]
Values = V | Callable[[AutocompleteContext], V | AV] | AV
AutocompleteFunc = Callable[[AutocompleteContext], AV]

def basic_autocomplete(values: Values) -> AutocompleteFunc: ...
def filter_params(params, **kwargs): ...
