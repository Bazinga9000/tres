import aiohttp
import threading
from _typeshed import Incomplete
from typing import NamedTuple

__all__ = ['DiscordWebSocket', 'KeepAliveHandler', 'VoiceKeepAliveHandler', 'DiscordVoiceWebSocket', 'ReconnectWebSocket']

class ReconnectWebSocket(Exception):
    shard_id: Incomplete
    resume: Incomplete
    op: Incomplete
    def __init__(self, shard_id, *, resume: bool = True) -> None: ...

class WebSocketClosure(Exception): ...

class EventListener(NamedTuple):
    predicate: Incomplete
    event: Incomplete
    result: Incomplete
    future: Incomplete

class GatewayRatelimiter:
    max: Incomplete
    remaining: Incomplete
    window: float
    per: Incomplete
    lock: Incomplete
    shard_id: Incomplete
    def __init__(self, count: int = 110, per: float = 60.0) -> None: ...
    def is_ratelimited(self): ...
    def get_delay(self): ...
    async def block(self) -> None: ...

class KeepAliveHandler(threading.Thread):
    ws: Incomplete
    interval: Incomplete
    daemon: bool
    shard_id: Incomplete
    msg: str
    block_msg: str
    behind_msg: str
    latency: Incomplete
    heartbeat_timeout: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    def run(self) -> None: ...
    def get_payload(self): ...
    def stop(self) -> None: ...
    def tick(self) -> None: ...
    def ack(self) -> None: ...

class VoiceKeepAliveHandler(KeepAliveHandler):
    recent_ack_latencies: Incomplete
    msg: str
    block_msg: str
    behind_msg: str
    def __init__(self, *args, **kwargs) -> None: ...
    def get_payload(self): ...
    latency: Incomplete
    def ack(self) -> None: ...

class DiscordClientWebSocketResponse(aiohttp.ClientWebSocketResponse):
    async def close(self, *, code: int = 4000, message: bytes = b'') -> bool: ...

class DiscordWebSocket:
    DISPATCH: int
    HEARTBEAT: int
    IDENTIFY: int
    PRESENCE: int
    VOICE_STATE: int
    VOICE_PING: int
    RESUME: int
    RECONNECT: int
    REQUEST_MEMBERS: int
    INVALIDATE_SESSION: int
    HELLO: int
    HEARTBEAT_ACK: int
    GUILD_SYNC: int
    socket: Incomplete
    loop: Incomplete
    thread_id: Incomplete
    session_id: Incomplete
    sequence: Incomplete
    resume_gateway_url: Incomplete
    def __init__(self, socket, *, loop) -> None: ...
    @property
    def open(self): ...
    def is_ratelimited(self): ...
    def debug_log_receive(self, data, /) -> None: ...
    def log_receive(self, _, /) -> None: ...
    @classmethod
    async def from_client(cls, client, *, initial: bool = False, gateway=None, shard_id=None, session=None, sequence=None, resume: bool = False): ...
    def wait_for(self, event, predicate, result=None): ...
    async def identify(self) -> None: ...
    async def resume(self) -> None: ...
    async def received_message(self, msg, /) -> None: ...
    @property
    def latency(self) -> float: ...
    async def poll_event(self) -> None: ...
    async def debug_send(self, data, /) -> None: ...
    async def send(self, data, /) -> None: ...
    async def send_as_json(self, data) -> None: ...
    async def send_heartbeat(self, data) -> None: ...
    async def change_presence(self, *, activity=None, status=None, since: float = 0.0) -> None: ...
    async def request_chunks(self, guild_id, query=None, *, limit, user_ids=None, presences: bool = False, nonce=None) -> None: ...
    async def voice_state(self, guild_id, channel_id, self_mute: bool = False, self_deaf: bool = False) -> None: ...
    async def close(self, code: int = 4000) -> None: ...

class DiscordVoiceWebSocket:
    IDENTIFY: int
    SELECT_PROTOCOL: int
    READY: int
    HEARTBEAT: int
    SESSION_DESCRIPTION: int
    SPEAKING: int
    HEARTBEAT_ACK: int
    RESUME: int
    HELLO: int
    RESUMED: int
    CLIENT_CONNECT: int
    CLIENT_DISCONNECT: int
    ws: Incomplete
    loop: Incomplete
    secret_key: Incomplete
    ssrc_map: Incomplete
    def __init__(self, socket, loop, *, hook=None) -> None: ...
    async def send_as_json(self, data) -> None: ...
    send_heartbeat = send_as_json
    async def resume(self) -> None: ...
    async def identify(self) -> None: ...
    @classmethod
    async def from_client(cls, client, *, resume: bool = False, hook=None): ...
    async def select_protocol(self, ip, port, mode) -> None: ...
    async def client_connect(self) -> None: ...
    async def speak(self, state=...) -> None: ...
    async def received_message(self, msg) -> None: ...
    async def initial_connection(self, data) -> None: ...
    @property
    def latency(self) -> float: ...
    @property
    def average_latency(self) -> list[float] | float: ...
    async def load_secret_key(self, data) -> None: ...
    async def poll_event(self) -> None: ...
    async def close(self, code: int = 1000) -> None: ...
