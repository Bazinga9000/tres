from .gateway import *
import asyncio
from . import abc
from .client import Client
from .guild import Guild
from .opus import Encoder
from .player import AudioSource
from .sinks import RawData
from .types.voice import GuildVoiceState as GuildVoiceStatePayload, SupportedModes, VoiceServerUpdate as VoiceServerUpdatePayload
from .user import ClientUser
from _typeshed import Incomplete
from typing import Any, Callable, Literal, overload

__all__ = ['VoiceProtocol', 'VoiceClient']

class VoiceProtocol:
    client: Client
    channel: abc.Connectable
    def __init__(self, client: Client, channel: abc.Connectable) -> None: ...
    async def on_voice_state_update(self, data: GuildVoiceStatePayload) -> None: ...
    async def on_voice_server_update(self, data: VoiceServerUpdatePayload) -> None: ...
    async def connect(self, *, timeout: float, reconnect: bool) -> None: ...
    async def disconnect(self, *, force: bool) -> None: ...
    def cleanup(self) -> None: ...

class VoiceClient(VoiceProtocol):
    endpoint_ip: str
    voice_port: int
    secret_key: list[int]
    ssrc: int
    token: str
    socket: Incomplete
    loop: asyncio.AbstractEventLoop
    mode: str
    sequence: int
    timestamp: int
    timeout: float
    encoder: Encoder
    decoder: Incomplete
    ws: DiscordVoiceWebSocket
    paused: bool
    recording: bool
    user_timestamps: Incomplete
    sink: Incomplete
    starting_time: Incomplete
    stopping_time: Incomplete
    def __init__(self, client: Client, channel: abc.Connectable) -> None: ...
    warn_nacl: Incomplete
    supported_modes: tuple[SupportedModes, ...]
    @property
    def guild(self) -> Guild | None: ...
    @property
    def user(self) -> ClientUser: ...
    def checked_add(self, attr, value, limit) -> None: ...
    session_id: Incomplete
    channel: Incomplete
    async def on_voice_state_update(self, data: GuildVoiceStatePayload) -> None: ...
    server_id: Incomplete
    endpoint: Incomplete
    async def on_voice_server_update(self, data: VoiceServerUpdatePayload) -> None: ...
    async def voice_connect(self) -> None: ...
    async def voice_disconnect(self) -> None: ...
    def prepare_handshake(self) -> None: ...
    def finish_handshake(self) -> None: ...
    async def connect_websocket(self) -> DiscordVoiceWebSocket: ...
    async def connect(self, *, reconnect: bool, timeout: float) -> None: ...
    async def potential_reconnect(self) -> bool: ...
    @property
    def latency(self) -> float: ...
    @property
    def average_latency(self) -> float: ...
    async def poll_voice_ws(self, reconnect: bool) -> None: ...
    async def disconnect(self, *, force: bool = False) -> None: ...
    async def move_to(self, channel: abc.Connectable) -> None: ...
    def is_connected(self) -> bool: ...
    @staticmethod
    def strip_header_ext(data): ...
    def get_ssrc(self, user_id): ...
    @overload
    def play(self, source: AudioSource, *, after: Callable[[Exception | None], Any] | None = None, wait_finish: Literal[False] = False) -> None: ...
    @overload
    def play(self, source: AudioSource, *, after: Callable[[Exception | None], Any] | None = None, wait_finish: Literal[True]) -> asyncio.Future: ...
    def unpack_audio(self, data) -> None: ...
    sync_start: Incomplete
    def start_recording(self, sink, callback, *args, sync_start: bool = False): ...
    def stop_recording(self) -> None: ...
    def toggle_pause(self) -> None: ...
    def empty_socket(self) -> None: ...
    first_packet_timestamp: float
    def recv_audio(self, sink, callback, *args) -> None: ...
    def recv_decoded_audio(self, data: RawData): ...
    def is_playing(self) -> bool: ...
    def is_paused(self) -> bool: ...
    def stop(self) -> None: ...
    def pause(self) -> None: ...
    def resume(self) -> None: ...
    @property
    def source(self) -> AudioSource | None: ...
    @source.setter
    def source(self, value: AudioSource) -> None: ...
    def send_audio_packet(self, data: bytes, *, encode: bool = True) -> None: ...
